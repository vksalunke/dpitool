<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Batch DPI Converter</title>
  <style>
    body {
      font-family: Arial;
      padding: 20px;
      background: #f9f9f9;
    }
    h2 { margin-bottom: 10px; }
    input[type="file"] { margin-bottom: 10px; }
    .preview { margin-top: 20px; display: flex; flex-wrap: wrap; gap: 20px; }
    .preview img { border: 1px solid #ccc; padding: 4px; background: white; }
  </style>
</head>
<body>

  <h2>Batch DPI Converter (132x170 px, 300 DPI)</h2>
  <input type="file" multiple accept="image/*" id="fileInput">
  <br>
  <button onclick="downloadAll()">Download All as ZIP</button>
  <div class="preview" id="preview"></div>

  <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.0/dist/jszip.min.js"></script>
  <script>
    const fileInput = document.getElementById('fileInput');
    const previewDiv = document.getElementById('preview');
    const zip = new JSZip();

    fileInput.addEventListener('change', async (e) => {
      previewDiv.innerHTML = "";
      zip.files = {}; // reset ZIP

      for (const file of e.target.files) {
        const img = await createImageBitmap(file);
        const canvas = document.createElement('canvas');
        canvas.width = 132;
        canvas.height = 170;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, 132, 170);

        const pngBlob = await canvasToDPIBlob(canvas, 300, 300);
        const dataURL = URL.createObjectURL(pngBlob);

        // Show preview
        const imgElem = document.createElement('img');
        imgElem.src = dataURL;
        imgElem.width = 132;
        imgElem.height = 170;
        previewDiv.appendChild(imgElem);

        // Add to ZIP
        const arrayBuffer = await pngBlob.arrayBuffer();
        zip.file(file.name.replace(/\.[^/.]+$/, "") + "_converted.png", arrayBuffer);
      }
    });

    async function canvasToDPIBlob(canvas, dpiX = 300, dpiY = 300) {
      const png = atob(canvas.toDataURL("image/png").split(",")[1]);
      const array = new Uint8Array(png.length);
      for (let i = 0; i < png.length; i++) array[i] = png.charCodeAt(i);

      // DPI metadata: 1 meter = 39.3701 inches, so 300 dpi = 11811 pixels/meter
      const pHYsChunk = new Uint8Array([
        ...[0x70, 0x48, 0x59, 0x73], // "pHYs"
        ...toBytes(11811), // X axis
        ...toBytes(11811), // Y axis
        1 // unit is meter
      ]);
      const length = toBytes(pHYsChunk.length - 4);
      const crc = crc32(pHYsChunk);

      const newChunk = new Uint8Array(4 + 4 + 9 + 4);
      newChunk.set(length, 0);
      newChunk.set(pHYsChunk, 4);
      newChunk.set(crc, 4 + 4 + 9);

      const iendIndex = array.findIndex((_, i) =>
        array[i] === 0x49 && array[i+1] === 0x45 &&
        array[i+2] === 0x4E && array[i+3] === 0x44
      ) - 4;

      const before = array.slice(0, iendIndex);
      const after = array.slice(iendIndex);
      const full = new Uint8Array(before.length + newChunk.length + after.length);
      full.set(before, 0);
      full.set(newChunk, before.length);
      full.set(after, before.length + newChunk.length);

      return new Blob([full], { type: "image/png" });
    }

    function toBytes(num) {
      return [
        (num >> 24) & 0xff,
        (num >> 16) & 0xff,
        (num >> 8) & 0xff,
        num & 0xff
      ];
    }

    function crc32(bytes) {
      let crc = 0xffffffff;
      for (let i = 0; i < bytes.length; i++) {
        crc ^= bytes[i];
        for (let j = 0; j < 8; j++) {
          crc = (crc >>> 1) ^ (0xedb88320 & -(crc & 1));
        }
      }
      return toBytes((crc ^ 0xffffffff) >>> 0);
    }

    function downloadAll() {
      zip.generateAsync({ type: "blob" }).then(content => {
        const a = document.createElement("a");
        a.href = URL.createObjectURL(content);
        a.download = "converted_images.zip";
        a.click();
      });
    }
  </script>
</body>
</html>
